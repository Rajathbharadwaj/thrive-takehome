name: Production CI/CD Pipeline

on:
  push:
    branches: 
      - main        # Deploy to PRODUCTION environment only
    paths:
      - 'app/**'              # Application code changes
      - 'terraform/**'        # Infrastructure changes  
      - 'k8s/**'             # Kubernetes manifests
      - '.github/workflows/**' # CI/CD pipeline changes
      - 'Dockerfile'         # Container changes
      - 'scripts/**'         # Deployment scripts
      # Exclude documentation changes
      - '!README.md'
      - '!docs/**'
      - '!*.md'
  pull_request:
    branches: [main]
    paths:
      - 'app/**'
      - 'terraform/**'  
      - 'k8s/**'
      - '.github/workflows/**'
      - 'Dockerfile'
      - 'scripts/**'
      - '!README.md'
      - '!docs/**'
      - '!*.md'

env:
  AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}

jobs:
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      cluster-name: ${{ steps.env.outputs.cluster-name }}
      ecr-repository: ${{ steps.env.outputs.ecr-repository }}
    
    steps:
    - name: Determine environment based on branch
      id: env
      run: |
        # Single production environment only
        echo "environment=prod" >> $GITHUB_OUTPUT
        echo "cluster-name=thrive-prod-cluster-fresh" >> $GITHUB_OUTPUT
        echo "ecr-repository=thrive-hello-world" >> $GITHUB_OUTPUT

  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: determine-environment
    permissions:
      id-token: write
      contents: read
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials using OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/thrive-github-actions
        aws-region: ${{ secrets.AWS_REGION }}
        audience: sts.amazonaws.com
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ steps.login-ecr.outputs.registry }}/${{ needs.determine-environment.outputs.ecr-repository }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
    


  deploy:
    name: Deploy to Environment
    runs-on: ubuntu-latest
    needs: [determine-environment, build]
    environment: ${{ needs.determine-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials using OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/thrive-github-actions
        aws-region: ${{ secrets.AWS_REGION }}
        audience: sts.amazonaws.com
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "~1.6"
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    
    - name: Verify infrastructure exists
      run: |
        # Verify EKS cluster exists (infrastructure should be deployed via setup.sh)
        aws eks describe-cluster --name ${{ needs.determine-environment.outputs.cluster-name }} || {
          echo "‚ùå EKS cluster not found! Please run './scripts/setup.sh' locally first."
          echo "‚ÑπÔ∏è  CI/CD is designed to update applications, not create infrastructure."
          exit 1
        }
        echo "‚úÖ Infrastructure verified - EKS cluster exists"
    
    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ needs.determine-environment.outputs.cluster-name }}
        # Verify kubectl access
        kubectl get nodes
    
    - name: Deploy application
      run: |
        # Get the ECR repository URL and use latest tag
        ECR_REPO="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ needs.determine-environment.outputs.ecr-repository }}"
        IMAGE_TAG="${ECR_REPO}:latest"
        
        echo "üöÄ Deploying image: $IMAGE_TAG"
        
        # Check if deployment exists, if not create it first
        if ! kubectl get deployment hello-world -n thrive-app >/dev/null 2>&1; then
          echo "üì¶ Deployment not found, applying Kubernetes manifests..."
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/deployment.yaml  # Contains both deployment and service
          kubectl apply -f k8s/ingress.yaml
          kubectl apply -f k8s/hpa.yaml
          
          # Wait for initial deployment
          echo "‚è≥ Waiting for initial deployment to be ready..."
          kubectl wait --for=condition=available deployment/hello-world -n thrive-app --timeout=300s
        fi
        
        # Update deployment with new image
        kubectl set image deployment/hello-world hello-world=$IMAGE_TAG -n thrive-app
        
        # Wait for rollout to complete
        kubectl rollout status deployment/hello-world -n thrive-app --timeout=300s
    
    - name: Run deployment verification
      run: |
        # Get service URL
        ALB_URL=$(kubectl get ingress hello-world-ingress -n thrive-app -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        
        # Wait for ALB to be ready
        echo "Waiting for ALB to be ready..."
        for i in {1..30}; do
          if curl -f -s "http://$ALB_URL/health" > /dev/null; then
            echo "‚úÖ Application is healthy!"
            break
          fi
          echo "Waiting... ($i/30)"
          sleep 10
        done
        
        # Test endpoints
        echo "Testing application endpoints:"
        curl -f "http://$ALB_URL/" || exit 1
        curl -f "http://$ALB_URL/health" || exit 1
        curl -f "http://$ALB_URL/metrics" | head -5
    
    - name: Notify deployment status
      if: always()
      run: |
        if [[ "${{ job.status }}" == "success" ]]; then
          echo "üéâ Deployment to ${{ needs.determine-environment.outputs.environment }} successful!"
        else
          echo "‚ùå Deployment to ${{ needs.determine-environment.outputs.environment }} failed!"
        fi
